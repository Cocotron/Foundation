{"version":3,"sources":["/Users/cbruno/Cocotron/Foundation/src/CTObject.j","/Users/cbruno/Cocotron/Foundation/src/CTArray.j","/Users/cbruno/Cocotron/Foundation/tests/CTArrayTest.j","/Users/cbruno/Cocotron/Foundation/src/CTDictionary.j","/Users/cbruno/Cocotron/Foundation/src/CTKeyValueCoding.j","/Users/cbruno/Cocotron/Foundation/tests/KVOTest.j","/Users/cbruno/Cocotron/Foundation/tests/tests.j"],"names":[],"mappings":"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","file":"debug.js","sourcesContent":["\n@implementation CTObject\n{\n    id isa; \n}\n\n+ (void)load\n{\n}\n\n+ (void)initialize\n{\n}\n\n/*!\n    Allocates a new instance of the receiver, and sends it an \\c -init\n    @return the new object\n */\n\n+ (id)new\n{\n    return [[self alloc] init]; \n}\n\n/*!\n    Allocates a new instance of the receiving class\n */\n\n+ (id)alloc\n{\n    return class_createInstance(self); \n}\n\n+ (id)allocWithCoder:(CPCoder)aCoder\n{\n    return [self alloc]; \n}\n\n/*!\n    Initializes the receiver\n    @return the initialized receiver\n */\n\n- (id)init\n{\n    return self; \n}\n\n/*!\n    Makes a deep copy of the receiver. The copy should be functionally equivalent to the receiver.\n    @return the copy of the receiver\n */\n\n- (id)copy\n{\n    return self; \n}\n\n/*!\n    Creates a deep mutable copy of the receiver.\n    @return the mutable copy of the receiver\n */\n\n- (id)mutableCopy\n{\n    return [self copy]; \n}\n\n\n    // Identifying classes\n/*!\n    Returns the Class object for this class definition.\n */\n\n+ (Class)class\n{\n    return self; \n}\n\n/*!\n    Returns the receiver's Class\n */\n\n- (Class)class\n{\n    return isa; \n}\n\n/*!\n    Returns the class object super class\n */\n\n+ (Class)superclass\n{\n    return self.super_class; \n}\n\n/*!\n    Returns \\c YES if the receiving class is a subclass of \\c aClass.\n    @param aClass the class to test inheritance from\n */\n\n+ (BOOL)isSubclassOfClass:(Class)aClass\n{\n    var theClass = self; \n\n    for (;theClass;theClass = theClass.super_class)\n        if (theClass === aClass)\n            return YES; \n\n    return NO; \n}\n\n/*!\n    Returns \\c YES if the receiver is a \\c aClass type, or a subtype of it.\n    @param aClass the class to test as the receiver's class or super class.\n */\n\n- (BOOL)isKindOfClass:(Class)aClass\n{\n    return [isa isSubclassOfClass:aClass]; \n}\n\n+ (BOOL)isKindOfClass:(Class)aClass\n{\n    return [self isSubclassOfClass:aClass]; \n}\n\n/*!\n    Returns \\c YES if the receiver is of the \\c aClass class type.\n    @param aClass the class to test the receiver\n */\n\n- (BOOL)isMemberOfClass:(Class)aClass\n{\n    return self.isa === aClass; \n}\n\n+ (BOOL)isMemberOfClass:(Class)aClass\n{\n    return self === aClass; \n}\n\n/*!\n    Determines whether the receiver's root object is a proxy.\n    @return \\c YES if the root object is a proxy\n */\n\n- (BOOL)isProxy\n{\n    return NO; \n}\n\n    // Testing class functionality\n/*!\n    Test whether instances of this class respond to the provided selector.\n    @param aSelector the selector for which to test the class\n    @return \\c YES if instances of the class respond to the selector\n */\n\n+ (BOOL)instancesRespondToSelector:(SEL)aSelector\n{\n    return !!class_getInstanceMethod(self, aSelector); \n}\n\n/*!\n    Tests whether the receiver responds to the provided selector.\n    @param aSelector the selector for which to test the receiver\n    @return \\c YES if the receiver responds to the selector\n */\n\n- (BOOL)respondsToSelector:(SEL)aSelector\n{\n    // isa is isa.isa in class case.\n    return !!class_getInstanceMethod(isa, aSelector); \n}\n\n/*!\n    Tests if instances of a given class implement the provided selector regardless of inheritance.\n    @param aSelector the selector for which to test the class\n    @return \\c YES if instances of the class implement the selector\n */\n\n+ (BOOL)instancesImplementSelector:(SEL)aSelector\n{\n    var methods = class_copyMethodList(self), count = methods.length; \n\n    while (count--)\n        if (method_getName(methods[count]) === aSelector)\n            return YES; \n\n    return NO; \n}\n\n/*!\n    Tests if the receiver implements the provided selector regardless of inheritance.\n    @param aSelector the selector for which to test the receiver\n    @return \\c YES if the receiver implements the selector\n */\n\n- (BOOL)implementsSelector:(SEL)aSelector\n{\n    return [[self class] instancesImplementSelector:aSelector]; \n}\n\n/*!\n    Test whether instances of this class conforms to the provided protocol.\n    @param aProtocol the protocol for which to test the class\n    @return \\c YES if instances of the class conforms to the protocol\n */\n\n+ (BOOL)conformsToProtocol:(Protocol)aProtocol\n{\n    return class_conformsToProtocol(self, aProtocol); \n}\n\n/*!\n    Tests whether the receiver conforms to the provided protocol.\n    @param protocol the protocol for which to test the class\n    @return \\c YES if instances of the class conforms to the protocol\n */\n\n- (BOOL)conformsToProtocol:(Protocol)aProtocol\n{\n    return class_conformsToProtocol(isa, aProtocol); \n}\n\n    // Obtaining method information\n\n/*!\n    Returns the implementation of the receiver's method for the provided selector.\n    @param aSelector the selector for the method to return\n    @return the method implementation ( a function )\n */\n\n- (IMP)methodForSelector:(SEL)aSelector\n{\n    return class_getMethodImplementation(isa, aSelector); \n}\n\n/*!\n    Returns the implementation of the receiving class' method for the provided selector.\n    @param aSelector the selector for the class method to return\n    @return the method implementation ( a function )\n */\n\n+ (IMP)instanceMethodForSelector:(SEL)aSelector\n{\n    return class_getMethodImplementation(self, aSelector); \n}\n\n/*!\n    Returns the method signature for the provided selector.\n    @param aSelector the selector for which to find the method signature\n    @return the selector's method signature\n */\n\n- (CPMethodSignature)methodSignatureForSelector:(SEL)aSelector\n{\n    // FIXME: We need to implement method signatures.\n    return nil; \n}\n\n    // Describing objects\n/*!\n    Returns a human readable string describing the receiver\n */\n\n- (CPString)description\n{\n    return \"<\" + class_getName(isa) + \" 0x\" + [CPString stringWithHash:[self UID]] + \">\"; \n}\n\n+ (CPString)description\n{\n    return class_getName(self.isa); \n}\n\n    // Sending Messages\n/*!\n    Sends the specified message to the receiver.\n    @param aSelector the message to send\n    @return the return value of the message\n */\n\n- (id)performSelector:(SEL)aSelector\n{\n    return self.isa.objj_msgSend0(self, aSelector); \n}\n\n/*!\n    Sends the specified message to the receiver, with one argument.\n    @param aSelector the message to send\n    @param anObject the message argument\n    @return the return value of the message\n */\n\n- (id)performSelector:(SEL)aSelector withObject:(id)anObject\n{\n    return self.isa.objj_msgSend1(self, aSelector, anObject); \n}\n\n/*!\n    Sends the specified message to the receiver, with two arguments.\n    @param aSelector the message to send\n    @param anObject the first message argument\n    @param anotherObject the second message argument\n    @return the return value of the message\n */\n\n- (id)performSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject\n{\n    return self.isa.objj_msgSend2(self, aSelector, anObject, anotherObject); \n}\n\n/*!\n    Sends the specified message to the reciever, with any number of arguments.\n    @param aSelector the message to send\n    @param anObject //... comma seperated objects to pass to the selector\n    @return the return value of the message\n */\n\n- (id)performSelector:(SEL)aSelector withObjects:(id)anObject, ...\n{\n    var params = [self, aSelector].concat(Array.prototype.slice.apply(arguments, [3])); \n\n    return objj_msgSend.apply(this, params); \n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector\n{\n    return nil; \n}\n\n    // Error Handling\n/*!\n    Called by the Objective-J runtime when an object can't respond to\n    a message. It's not recommended to call this method directly, unless\n    you need your class to not support a method that it has inherited from a super class.\n */\n\n- (void)doesNotRecognizeSelector:(SEL)aSelector\n{\n    throw new Error(class_isMetaClass(isa) ? \"+\" : \"-\" + \" [\" + [self className] + \" \" + aSelector + \"] unrecognized selector sent to \" + \"class \" + class_getName(isa)\n    ); \n}\n\n    // Archiving\n/*!\n    Subclasses override this method to possibly substitute\n    the unarchived object with another. This would be\n    useful if your program utilizes a\n    <a href=\"http://en.wikipedia.org/wiki/Flyweight_pattern\">flyweight pattern</a>.\n    The method is called by CPCoder.\n    @param aCoder the coder that contained the receiver's data\n */\n\n- (id)awakeAfterUsingCoder:(CPCoder)aCoder\n{\n    return self; \n}\n\n/*!\n    Can be overridden by subclasses to substitute a different class to represent the receiver for keyed archiving.\n    @return the class to use. A \\c nil means to ignore the method result.\n */\n\n- (Class)classForKeyedArchiver\n{\n    return [self classForCoder]; \n}\n\n/*!\n    Can be overridden by subclasses to substitute a different class to represent the receiver during coding.\n    @return the class to use for coding\n */\n\n- (Class)classForCoder\n{\n    return [self class]; \n}\n\n/*!\n    Can be overridden by subclasses to substitute another object during archiving.\n    @param anArchiver that archiver\n    @return the object to archive\n */\n\n- (id)replacementObjectForArchiver:(CPArchiver)anArchiver\n{\n    return [self replacementObjectForCoder:anArchiver]; \n}\n\n/*!\n    Can be overridden by subclasses to substitute another object during keyed archiving.\n    @param anArchive the keyed archiver\n    @return the object to archive\n */\n\n- (id)replacementObjectForKeyedArchiver:(CPKeyedArchiver)anArchiver\n{\n    return [self replacementObjectForCoder:anArchiver]; \n}\n\n/*!\n    Can be overridden by subclasses to substitute another object during coding.\n    @param aCoder the coder\n    @return the object to code\n */\n\n- (id)replacementObjectForCoder:(CPCoder)aCoder\n{\n    return self; \n}\n\n/*!\n    Sets the class version number.\n    @param the new version number for the class\n */\n\n+ (void)setVersion:(int)aVersion\n{\n    class_setVersion(self, aVersion); \n}\n\n/*!\n    Returns the class version number.\n */\n\n+ (int)version\n{\n    return class_getVersion(self); \n}\n\n    // Scripting (?)\n/*!\n    Returns the class name\n */\n\n- (CPString)className\n{\n    // FIXME: Why doesn't this work in KVO???\n    // return class_getName([self class]);\n    return isa.name; \n}\n\n\n/*!\n    Returns a hash for the object\n */\n\n- (unsigned)hash\n{\n    return [self UID]; \n}\n\n- (CPString)UID\n{ \n    if (typeof self._UID === \"undefined\") { \n        self._UID = objj_generateObjectUID();    \n    }\n    return self._UID + \"\"; \n}\n\n/*!\n    Determines if \\c anObject is functionally equivalent to the receiver.\n    @return \\c YES if \\c anObject is functionally equivalent to the receiver.\n */\n\n- (BOOL)isEqual:(id)anObject\n{\n    return self === anObject || [self UID] === [anObject UID]; \n}\n\n/*!\n    Returns the receiver.\n */\n\n- (id)self\n{\n    return self; \n}\n\n/*!\n    Returns the receiver's super class.\n */\n\n- (Class)superclass\n{\n    return isa.super_class; \n}\n@end\n\nfunction CPDescriptionOfObject(anObject, maximumRecursionDepth)\n{\n    if (anObject === nil)\n        return \"nil\"; \n\n    if (anObject === undefined)\n        return \"undefined\"; \n\n    if (anObject === window)\n        return \"window\"; \n\n    if (maximumRecursionDepth === 0)\n        return \"...\"; \n\n    if (anObject.isa)\n    {\n        if ([anObject isKindOfClass:CPString])\n            return '@\"' + [anObject description] + '\"'; \n\n        if ([anObject respondsToSelector:@selector(_descriptionWithMaximumDepth:)])\n            return [anObject _descriptionWithMaximumDepth:maximumRecursionDepth !== undefined ? maximumRecursionDepth - 1 : maximumRecursionDepth]; \n\n        return [anObject description]; \n    }\n\n    if (typeof anObject !== \"object\")\n        return String(anObject); \n\n    var properties = [], desc; \n\n    for(var property in anObject)\n        if (anObject.hasOwnProperty(property))\n            properties.push(property); \n\n    properties.sort(); \n    \n    if (properties.length === 2 && anObject.hasOwnProperty(\"width\") && anObject.hasOwnProperty(\"height\"))\n        desc = [CPString stringWithFormat:\"CGSize: (%f, %f)\", anObject.width, anObject.height]; \n    else\n    if (properties.length === 2 && anObject.hasOwnProperty(\"x\") && anObject.hasOwnProperty(\"y\"))\n        desc = [CPString stringWithFormat:\"CGPoint: (%f, %f)\", anObject.x, anObject.y]; \n    else\n    if (properties.length === 2 && anObject.hasOwnProperty(\"origin\") && anObject.hasOwnProperty(\"size\"))\n        desc = [CPString stringWithFormat:\"CGRect: (%f, %f), (%f, %f)\", anObject.origin.x, anObject.origin.y, anObject.size.width, anObject.size.height]; \n    else\n    if (properties.length === 4 && anObject.hasOwnProperty(\"top\") && anObject.hasOwnProperty(\"right\") && anObject.hasOwnProperty(\"bottom\") && anObject.hasOwnProperty(\"left\"))\n        desc = [CPString stringWithFormat:\"CGInset: { top:%f, right:%f, bottom:%f, left:%f }\", anObject.top, anObject.right, anObject.bottom, anObject.left]; \n    else\n    {\n        desc = \"{\"; \n        \n        for (var i = 0;i < properties.length;++i)\n        {\n            if (i === 0)\n                desc += \"\\n\"; \n\n            var value = anObject[properties[i]], valueDescription = ((CPDescriptionOfObject(value, maximumRecursionDepth !== undefined ? maximumRecursionDepth - 1 : maximumRecursionDepth)).split(\"\\n\")).join(\"\\n    \"); \n\n            desc += \"b\" + properties[i] + \": \" + valueDescription; \n            \n            if (i < properties.length - 1)\n                desc += \",\\n\"; \n            else\n                desc += \"\\n\"; \n        }\n\n        desc += \"}\"; \n    }\n\n    return desc; \n}","\n//-#import \"CTObject.j\"\n\n@implementation CTArray : CTObject\n\n+ (id)alloc\n{\n    return [];\n}\n\n+ (id)array\n{\n    return [];\n}\n\n+(id) arrayWithObjects:(id)anObject, ... \n{\n    var index = 2,\n        count = arguments.length;\n    for (; index < count; ++index)\n        if (arguments[index] === nil)\n            break;\n    return Array.prototype.slice.call(arguments, 2, index);        \n}\n\n\n-(void) addObject:(id)anObject \n{\n    self.push(anObject);\n}\n\n-(void) removeObject:(id)anObject\n{\n    var anIndex;\n    while ((anIndex = self.indexOf.call(self, anObject)) !== -1)\n            self.splice.call(self, anIndex, 1);\n}\n\n-(void) removeAt:(Integer)anIndex \n{\n    self.splice.call(self, anIndex, 1);\n}\n\n-(void) insertObject:(id)anObject at:(Integer)anIndex \n{\n    self.splice.call(self, anIndex, 0, anObject);\n}\n\n-(void) removeAllObjects \n{\n    self.splice.call(self, 0, self.length);\n}\n\n-(Integer) count {\n    return self.length; \n}\n\n@end\n\nArray.prototype.isa = CTArray;\n\n","\n//-#import \"../src/CTArray.j\"\n\n//Test Array\nlet array = [CTArray arrayWithObjects:@\"One\", @\"Two\", @\"Three\"];\n\n[array addObject:\"Hello2\"];\n\n[array insertObject:\"Dog\" at:2];\n\n\n[array addObject:nil];\n\nconsole.log(\"CTArray:\");\nconsole.log(array);\n\n[array removeAt:0];\n\n\n\nconsole.log([array count])   ;   \n","\n\n//-#import \"CTObject.j\"\n//-#import \"CTArray.j\"\n\n@implementation CTDictionary : CTObject\n\n+(id) alloc \n{\n    return new Map();\n}\n\n+(id) dictionary {\n    return new Map();\n}\n\n-(CTArray) allKeys\n{\n    return Array.from(self.keys.call(self));\n}\n\n-(CTArray) allObjects\n{\n    return Array.from(self.values.call(self))\n}\n\n-(BOOL) containsKey:(String)aKey \n{\n    return self.has.call(self, aKey);\n}\n\n-(id) objectForKey:(String)aKey \n{\n    return self.get.call(self, aKey);\n}\n\n-(void) setObject:(id)anObject forKey:(String)aKey \n{\n    self.set.call(self, aKey, anObject);\n} \n\n-(void) removeObjectForKey:(String)aKey {\n    self.delete.call(self, aKey);\n}\n\n-(Integer) count \n{\n    return self.size.call(self);\n}\n\n@end\n\nMap.prototype.isa = CTDictionary;\n","\n\n//-#import \"CTObject.j\"\n//-#import \"CTDictionary.j\"\n\n@implementation CTObject (KVC)\n \n-(id) valueForKey:(String)aKey {\n\n    if([self respondsToSelector:@selector(aKey)]) {\n        return [self performSelector:@selector(aKey)];\n    }\n\n    if(self[aKey]) {\n        return self[aKey];\n    }\n\n    throw new Error(`${[self class]} does not respond to key ${aKey}`);\n}\n\n- (id)valueForKeyPath:(CPString)aKeyPath\n{\n    const firstDotIndex = aKeyPath.indexOf(\".\");\n\n    if (firstDotIndex < 0)\n        return [self valueForKey:aKeyPath];\n\n    const firstKeyComponent = aKeyPath.substring(0, firstDotIndex),\n        remainingKeyPath = aKeyPath.substring(firstDotIndex + 1),\n        value = [self valueForKey:firstKeyComponent];\n\n    return [value valueForKeyPath:remainingKeyPath];\n}\n\n-(void) setValue:(id)aValue forKey:(String)aKey {\n\n    var capitalizedKey = aKey.charAt(0).toUpperCase() + aKey.substring(1),\n        _selector = sel_getUid(\"set\" + capitalizedKey + \":\");\n    if([self respondsToSelector:_selector]) {\n        [self performSelector:_selector withObject:aValue]; \n    }\n    else {\n        self[aKey] = aValue; \n    }\n    \n    \n}\n\n-(void) setValue:(id)aValue forKeyPath:(String)aKeyPath {\n\n    if (!aKeyPath)\n        aKeyPath = @\"self\";\n\n    const firstDotIndex = aKeyPath.indexOf(\".\");\n\n    if (firstDotIndex < 0)\n        return [self setValue:aValue forKey:aKeyPath];\n\n    const firstKeyComponent = aKeyPath.substring(0, firstDotIndex),\n          remainingKeyPath = aKeyPath.substring(firstDotIndex + 1),\n          value = [self valueForKey:firstKeyComponent];\n\n    return [value setValue:aValue forKeyPath:remainingKeyPath];\n}\n\n@end\n\n\n@implementation CTDictionary (KVC)\n \n- (id)valueForKey:(String)aKey\n{\n    return [self objectForKey:aKey];\n}\n\n- (void)setValue:(id)aValue forKey:(String)aKey\n{\n    if (aValue != nil)\n        [self setObject:aValue forKey:aKey];\n    else\n        [self removeObjectForKey:aKey];\n}\n\n@end\n","\n//-#import \"../src/CTKeyValueCoding.j\";\n\n\n@implementation Pet : CTObject\n{\n   String name;\n}\n\n@end\n\n@implementation Person : CTObject\n{\n    Integer age         @accessors;\n    Pet     pet         @accessors; \n}\n\n-(id) init {\n\n    self = [super init];\n\n    pet = [Pet new];\n\n    return self;\n}\n\n\n@end\n\n\nvar p = [Person new];\n \np.pet.name = @\"Carter\";\np.age = 20;\n\nconsole.log([p respondsToSelector:@\"age\"]);\nalert([p valueForKeyPath:@\"pet.name\"])\n\n[p setValue:@\"Oksana\" forKeyPath:@\"pet.name\"];\n\nalert(p.pet.name);\n","\n//-#import \"CTArrayTest.j\"\n// #import \"CTSetTest.j\"\n// #import \"CTDictionaryTest.j\"\n// #import \"CTStringTest.j\"\n// #import \"CTCountedSetTest.j\"\n//-#import \"KVOTest.j\"\n\n"]}